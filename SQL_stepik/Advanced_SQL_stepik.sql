3.5 База данных "Учебная аналитика по курсу"


1. /*Отобрать все шаги, в которых рассматриваются вложенные запросы (то есть в названии шага упоминаются вложенные запросы). Указать к какому 
уроку и модулю они относятся. Для этого вывести 3 поля:
в поле Модуль указать номер модуля и его название через пробел;
в поле Урок указать номер модуля, порядковый номер урока (lesson_position) через точку и название урока через пробел;
в поле Шаг указать номер модуля, порядковый номер урока (lesson_position) через точку, порядковый номер шага (step_position) через точку и 
название шага через пробел.
Длину полей Модуль и Урок ограничить 19 символами, при этом слишком длинные надписи обозначить многоточием в конце (16 символов - это номер 
модуля или урока, пробел и  название Урока или Модуля,к ним присоединить "..."). Информацию отсортировать по возрастанию номеров модулей, 
порядковых номеров уроков и порядковых номеров шагов.*/

SELECT
    IF(
        LENGTH(CONCAT(module_id, ' ', module_name)) > 16,
        CONCAT(LEFT(CONCAT(module_id, ' ', module_name), 16), '...'),
        CONCAT(module_id, ' ', module_name)
        ) AS Модуль,
    IF(
        LENGTH(CONCAT(module_id, '.', lesson_position, ' ', lesson_name)) > 16,
        CONCAT(LEFT(CONCAT(module_id, '.', lesson_position, ' ', lesson_name), 16), '...'),
        CONCAT(module_id, '.', lesson_position, ' ', lesson_name)
        ) AS Урок,
    CONCAT(module_id, '.', lesson_position, '.', step_position, ' ', step_name) AS Шаг
FROM module
    JOIN lesson USING(module_id)
    JOIN step USING(lesson_id)
WHERE step_name LIKE '%ложенн% %апрос%'
ORDER BY Модуль, Урок, Шаг;



2.REGEX и INSTR()

/*Заполнить таблицу step_keyword следующим образом: если ключевое слово есть в названии шага, то включить в step_keyword строку с id шага 
и id ключевого слова. */

INSERT INTO step_keyword (step_id, keyword_id)
SELECT step_id, keyword_id
FROM keyword CROSS JOIN step
WHERE step_name REGEXP CONCAT('\\b', keyword_name, '\\b');

/*REGEXP позволяет задать регулярное выражение, которому должно соответствовать значение столбца. В этом плане REGEXP представляет более изощренный 
и комплексный способ фильтрации, нежели оператор LIKE. Это ссылка на документацию (https://dev.mysql.com/doc/refman/8.0/en/regexp.html#regexp-syntax)

REGEXP имеет похожий синтаксис:
WHERE выражение [NOT] REGEXP регулярное выражение

Регулярное выражение может принимать следующие специальные символы:
1) ^   указывает на начало строки
2) $   указывает на конец строки
3) .    соответствует любому одиночному символу
4) [символы]    соответствует любому одиночному символу из квадратных скобок
5) [начальный_символ-конечный_символ]: соответствует любому одиночному символу из диапазона символов
6) |     отделяет два шаблона строки, и значение должно соответствовать одному из этих шаблонов

Примеры REGEXP:

WHERE ProductName REGEXP 'Phone': строка должна содержать "Phone", например, iPhone X, Nokia Phone N, iPhone

WHERE ProductName REGEXP '^Phone': строка должна начинаться с "Phone", например, Phone 34, PhoneX

WHERE ProductName REGEXP 'Phone$': строка должна заканчиваться на "Phone", например, iPhone, Nokia Phone

WHERE ProductName REGEXP 'iPhone [78]';: строка должна содержать либо iPhone 7, либо iPhone 8

WHERE ProductName REGEXP 'iPhone [6-8]';: строка должна содержать либо iPhone 6, либо iPhone 7, либо iPhone 8

Например, найдем товары, названия которых содержат либо "Phone", либо "Galaxy":

SELECT * FROM Products
WHERE ProductName REGEXP 'Phone|Galaxy';


Можно было решать через INSTR, но REGEXP лучше

1. Чтобы проверить, есть ли ключевое слово в заголовке шага, можно использовать функцию:

INSTR(string_1, string_2)
которая возвращает позицию первого вхождения string_2 в string_1. Если вхождения нет - результат функции 0.

2. Некоторые ключевые слова, например IN, входят в INNER и JOIN. Нужно учитывать только отдельные слова, 
которые разделены в названии шага либо пробелом, либо запятой, либо открывающей скобкой.*/



3. /*Реализовать поиск по ключевым словам. Вывести шаги, с которыми связаны ключевые слова MAX и AVG одновременно. Для шагов указать id модуля, 
позицию урока в модуле, позицию шага в уроке через точку, после позиции шага перед заголовком - пробел. Позицию шага в уроке вывести в виде 
двух цифр (если позиция шага меньше 10, то перед цифрой поставить 0). Столбец назвать Шаг. Информацию отсортировать по первому столбцу 
в алфавитном порядке.*/

SELECT 
  CONCAT(
    module_id, '.', 
    lesson_position,'.', 
    IF(
      step_position < 10, 
      CONCAT('0', step_position), 
      step_position
    ), ' ', 
    step_name
  ) AS Шаг 
FROM 
  module 
  INNER JOIN lesson USING(module_id) 
  INNER JOIN step USING(lesson_id) 
  INNER JOIN step_keyword USING(step_id) 
  INNER JOIN keyword USING(keyword_id) 
WHERE keyword_name IN ('MAX', 'AVG')    -- отобрали шаги, у которых keyword_name это MAX или AVG или и то, и то
GROUP BY 1 
HAVING COUNT(keyword_name) = 2    -- отобрали шаги, у которых keyword_name это и MAX, и AVG
ORDER BY Шаг;

-- Отбор строк, где два ключевых слова можно было реализовать с помощью вложенных запросов
WHERE step_id IN (SELECT step_id FROM step_keyword INNER JOIN keyword WHERE keyword_name = 'AVG')
	AND step_id IN (SELECT step_id FROM step_keyword INNER JOIN keyword WHERE keyword_name = 'MAX')


-- Добавление '0' к цифрам от 1 до 9 можно было реализовать не через IF, а черезе LPAD()

/*LPAD ( исходная_строка, длина_строки [, символы_для_вставки ] ) → text

Расширяет исходную_строку до длины_строки, добавляя перед строкой символы_для_вставки (по умолчанию пробел). Если исходная_строка уже 
длиннее длины_строки, то она усекается (справа).

SELECT LPAD('Стоп', 7, 'xy') → xyxСтоп

SELECT LPAD('3', 4, '0') → 0003

LPAD(step_position, 2, '0'), которая добавляет ведущий ноль к позиции шага (step_position) при форматировании вывода. 
Теперь позиция шага будет отображаться в формате с двумя цифрами (с ведущим нулем для значений от 1 до 9).*/



4. Выборка данных по нескольким условиям, оператор CASE

/*С помощью оператора CASE можно в зависимости от нескольких условий получить один из нескольких результатов.

Оператор CASE записывается в виде:*/

CASE  
     WHEN логическое_выражение_1 THEN выражение_1
     WHEN логическое_выражение_2 THEN выражение_2
     ...
     ELSE выражение_else   
END 

/*Раздел ELSE является необязательным.

Выполняется оператор CASE так:

1) вычисляется логическое_выражение_1, если оно истинно, то результатом оператора является выражение_1, если ложно - выполнение 
оператора продолжается;
2) вычисляется логическое_выражение_2, если оно истинно, то результатом оператора является выражение_2, если ложно - выполнение 
оператора продолжается;
3) если все логические выражения оказались ложными, то результат оператора - выражение_else

CASE можно использовать в  SELECT, UPDATE, DELETE, SET, WHERE, ORDER BY, HAVING - всюду, где можно использовать выражения.*/

/*Отнести каждого студента к группе,  в зависимости от пройденных заданий.
Посчитать, сколько студентов относится к каждой группе. Столбцы назвать Группа, Интервал, Количество. Указать границы интервала.*/

SELECT  
    CASE
        WHEN rate <= 10 THEN "I"
        WHEN rate <= 15 THEN "II"
        WHEN rate <= 27 THEN "III"
        ELSE "IV"
    END AS Группа,
    CASE
        WHEN rate <= 10  THEN "от 0 до 10"
        WHEN rate <= 15 THEN "от 11 до 15"
        WHEN rate <= 27 THEN "от 16 до 27"
        ELSE "больше 27"
    END AS Интервал,
    COUNT(student_name) AS Количество
FROM      
    (
     SELECT student_name, count(*) as rate
     FROM 
         (
          SELECT student_name, step_id
          FROM 
              student 
              INNER JOIN step_student USING(student_id)
          WHERE result = "correct"
          GROUP BY student_name, step_id
         ) query_in
     GROUP BY student_name 
     ORDER BY 2
    ) query_in_1
GROUP BY Группа, Интервал;



5. Табличные выражения, оператор WITH

-- Табличное выражение определяется с помощью оператора WITH и является частью запроса. Его синтаксис: 

WITH имя_выражения (имя_1, имя_2,...)
  AS
    (
     SELECT столбец_1, столбец_2,
     FROM 
       ... 
     )
SELECT ...
   FROM имя_выражения
   ...
/*В табличном выражении определяется запрос, результат которого нужно использовать в основной части запроса после SELECT. 
При этом основной запрос может обратиться к столбцам результата табличного выражения через имена, заданные в заголовке WITH. 
При этом количество имен должно совпадать с количеством результирующих столбцов табличного выражения.

В одном запросе может быть несколько табличных выражений. При этом в каждом табличном выражении можно использовать все предшествующие 
ему табличные выражения.

В табличном выражении необязательно давать имена столбцам результата. В этом случае в основном запросе можно использовать имена столбцов, 
указанных после SELECT в табличном выражении. При наличии одинаковых имен в нескольких табличных выражениях необходимо использовать 
полное имя столбца (имя табличного выражения, точка, имя столбца).*/


/*Для каждого шага вывести процент правильных решений. Информацию упорядочить по возрастанию процента верных решений. 
Столбцы результата назвать Шаг и Успешность, процент успешных решений округлить до целого.

Исправить запрос примера так: для шагов, которые  не имеют неверных ответов,  указать 100 как процент успешных попыток, если же шаг 
не имеет верных ответов, указать 0. Информацию отсортировать сначала по возрастанию успешности, а затем по названию шага 
в алфавитном порядке.*/

WITH get_count_correct (st_n_c, count_correct) 
  AS (
    SELECT step_name, count(*)         -- запрос, который для каждого шага вычисляет количество правильных ответов, данных пользователями
    FROM 
        step 
        INNER JOIN step_student USING (step_id)
    WHERE result = "correct"
    GROUP BY step_name
   ),
  get_count_wrong (st_n_w, count_wrong) 
  AS (
    SELECT step_name, count(*)         -- запрос, который для каждого шага вычисляет количество неверных ответов, данных пользователями
    FROM 
        step 
        INNER JOIN step_student USING (step_id)
    WHERE result = "wrong"
    GROUP BY step_name
   )  
SELECT st_n_c AS Шаг,
    IFNULL(ROUND(count_correct / (count_correct + count_wrong) * 100), 100) AS Успешность
FROM  
    get_count_correct 
    LEFT JOIN get_count_wrong ON st_n_c = st_n_w
UNION
SELECT st_n_w AS Шаг,
    IFNULL(ROUND(count_correct / (count_correct + count_wrong) * 100), 0) AS Успешность
FROM  
    get_count_correct 
    RIGHT JOIN get_count_wrong ON st_n_c = st_n_w
ORDER BY Успешность, Шаг;



6. /*Вычислить прогресс пользователей по курсу. Прогресс вычисляется как отношение верно пройденных шагов к общему количеству шагов в 
процентах, округленное до целого. В нашей базе данные о решениях занесены не для всех шагов, поэтому общее количество шагов определить 
как количество различных шагов в таблице step_student.

Тем пользователям, которые прошли все шаги (прогресс = 100%) выдать "Сертификат с отличием". Тем, у кого прогресс больше или равен 80% - 
"Сертификат". Для остальных записей в столбце Результат задать пустую строку ("").

Информацию отсортировать по убыванию прогресса, затем по имени пользователя в алфавитном порядке.*/

SET @all_step = (
    SELECT COUNT(DISTINCT step_id)
    FROM step_student
    );
WITH student_result
AS (
    SELECT student_id,
        ROUND(COUNT(DISTINCT step_id)/@all_step*100) AS Прогресс
    FROM step_student
        RIGHT JOIN student USING(student_id)
    WHERE result = 'correct'
    GROUP BY student_id
   )
SELECT student_name AS Студент,
    Прогресс,
    CASE
        WHEN Прогресс = 100 THEN 'Сертификат с отличием'    -- Вот так тоже можно IF(Прогресс = 100, 'Сертификат с отличием', IF(Прогресс >= 80, 'Сертификат', '')) AS Результат
        WHEN Прогресс >= 80 THEN 'Сертификат'
        ELSE ''
    END AS Результат
FROM student_result
    RIGHT JOIN student USING(student_id) 
ORDER BY Прогресс DESC, Студент;



7. Оконные функции, оператор OVER, ORDER BY

/*Оконные функции позволяют получить некоторую дополнительную информацию о выборке данных.  С помощью оконных функций можно реализовать 
вычисления для набора строк, некоторым образом связанных с текущей строкой. При этом использование оконной функции не группирует несколько 
строк в одну, а сохраняет все строки запроса. Синтаксис оконных функций:*/

название_функции(выражение) 
  OVER (
        PARTITION BY столбец_1, столбец_2, ... - это окно
        ORDER BY ... - сортировка 
        ROWS BETWEEN - границы окна
          ...
  )

/*Причем все разделы OVER являются не обязательными, но обязательно нужно указать либо окно, либо сортировку. 
Cамый простой синтаксис оконного выражения:*/

название_функции(выражение) 
  OVER (
        ORDER BY ...
  )

/*Такое оконное выражение позволяет выполнять одинаковые действия над всеми записями таблицы (здесь окно - вся таблица). В качестве 
функций можно использовать:*/

ROW_NUMBER() - просто нумерация строк;

RANK() - ранжирование строк - при одинаковом значении строкам присваивается один номер, с пропуском номеров;

DENSE_RANK() - ранжирование строк без пропуска номеров;

LAG() - выбирает строку, предшествующую текущей, если таковой нет - выдается NULL;

LEAD() - выбирает строку, следующую за текущей, если таковой нет - выдается NULL.


/*Для студента с именем student_61 вывести все его попытки: название шага, результат и дату отправки попытки (submission_time). 
Информацию отсортировать по дате отправки попытки и указать, сколько минут прошло между отправкой соседних попыток. Название шага 
ограничить 20 символами и добавить "...". Столбцы назвать Студент, Шаг, Результат, Дата_отправки, Разница.*/

SELECT student_name Студент,
    CONCAT(LEFT(step_name, 20), '...') Шаг,
    result Результат,
    FROM_UNIXTIME(submission_time) Дата_отправки,
    SEC_TO_TIME(
        submission_time - LAG(submission_time, 1, submission_time) OVER (ORDER BY submission_time) 
        ) AS Разница
FROM step
    LEFT JOIN step_student USING(step_id)
    LEFT JOIN student USING(student_id)
WHERE student_name = 'student_61';

/*LAG(submission_time,1,submission_time) 
первый аргумент - LAG(submission_time) - предыдущая сабмишн
второй аргумент - 1 - через сколько строк брать предыдущее значение
третий аргумент - submission_time - Если вычисленное значение Null, то взять текущее значение сабмишн*/



8. /*Посчитать среднее время, за которое пользователи проходят урок по следующему алгоритму:
1) Для каждого пользователя вычислить время прохождения шага как сумму времени, потраченного на каждую попытку (время попытки - это 
разница между временем отправки задания и временем начала попытки), при этом попытки, которые длились больше 4 часов не учитывать, 
так как пользователь мог просто оставить задание открытым в браузере, а вернуться к нему на следующий день;

2) Для каждого студента посчитать общее время, которое он затратил на каждый урок;

3) Вычислить среднее время выполнения урока в часах, результат округлить до 2-х знаков после запятой;

4) Вывести информацию по возрастанию времени, пронумеровав строки, для каждого урока указать номер модуля и его позицию в нем.
Столбцы результата назвать Номер, Урок, Среднее_время.*/

WITH step_time AS (
	SELECT student_id,
        step_id,
        SUM(submission_time - attempt_time) AS st_time
    FROM step_student
    WHERE submission_time - attempt_time < 4 * 3600
    GROUP BY student_id, step_id
),
lesson_time AS (
	SELECT module_id,
    	lesson_position,
    	lesson_name,
    	SUM(st_time) AS les_time
	FROM step_time
    	INNER JOIN step USING(step_id)
    	INNER JOIN lesson USING(lesson_id)
	GROUP BY module_id, lesson_position,lesson_name, student_id
)
SELECT 
    ROW_NUMBER() OVER (ORDER BY ROUND(AVG(les_time) / 3600, 2)) AS Номер,
    CONCAT(module_id, '.', lesson_position, ' ', lesson_name) AS Урок,
    ROUND(AVG(les_time) / 3600, 2) AS Среднее_время
FROM lesson_time
GROUP BY Урок;



9. Оконные функции, оператор OVER, PARTITION BY

название_функции(выражение) 
  OVER (
        PARTITION BY ...
        ORDER BY ... 
  )

/*Такое оконное выражение позволяет выполнять одинаковые действия над всеми записями таблицы, ограниченными "окном". Столбцы, образующие 
окно записываются после  PARTITION BY. Окном считается совокупность записей, имеющих в столбцах, указанных после  PARTITION BY, 
одинаковые значения.*/



-- Пример: Вычислить, сколько шагов прошел пользователь по каждому модулю. Ранжировать пользователей по убыванию результатов в каждом модуле.

WITH get_rate_lesson(mod_id, stud, rate) 
AS
(
   SELECT module_id, student_name, count(DISTINCT step_id)
   FROM student INNER JOIN step_student USING(student_id)
                INNER JOIN step USING (step_id)
                INNER JOIN lesson USING (lesson_id)
   WHERE result = "correct"
   GROUP BY module_id, student_name
)
SELECT mod_id AS Модуль, stud AS Студент, rate AS Рейтинг,
    ROW_NUMBER() OVER (PARTITION BY mod_id ORDER BY  rate DESC) AS Номер,
    RANK() OVER (PARTITION BY mod_id ORDER BY  rate DESC) AS Ранг,
    DENSE_RANK() OVER (PARTITION BY mod_id ORDER BY  rate DESC) AS Рейтинг  
FROM get_rate_lesson 



-- Другой тип функций - это функции, которые используются для вычислений со значениями столбцов, входящих в окно:

SUM(), MAX(), MIN(), AVG(), COUNT()

/*По записи они точно соответствуют групповым функциям, при этом вычисленное значение заносится в каждую запись окна. В то время 
как при использовании группировки возвращается одна запись для каждой группы.

Как правило, эти функции используются в следующем контексте:*/

название_функции(выражение) 
  OVER (
        PARTITION BY ...
  )



/*Пример: Посчитать, сколько шагов пройдено пользователями по каждому уроку. Вывести максимальное и минимальное значение пройденных 
шагов по каждому модулю.*/

WITH get_rate_lesson(mod_id, les, rate) 
AS
(
   SELECT module_id,CONCAT(module_id,'.', lesson_position),count(DISTINCT step_id)
   FROM step_student INNER JOIN step USING (step_id)
                     INNER JOIN lesson USING (lesson_id)
   WHERE result = "correct"
   GROUP BY module_id, 2
)
SELECT mod_id AS Модуль, les AS Урок, rate AS Пройдено_шагов, 
    MAX(rate) OVER (PARTITION BY mod_id) AS Максимум_по_модулю,
    MIN(rate) OVER (PARTITION BY mod_id) AS Минимум_по_модулю
FROM get_rate_lesson 



/*Вычислить рейтинг каждого студента относительно студента, прошедшего наибольшее количество шагов в модуле (вычисляется как отношение 
количества пройденных студентом шагов к максимальному количеству пройденных шагов, умноженное на 100). Вывести номер модуля, имя студента, 
количество пройденных им шагов и относительный рейтинг. Относительный рейтинг округлить до одного знака после запятой. Столбцы назвать 
Модуль, Студент, Пройдено_шагов и Относительный_рейтинг  соответственно. Информацию отсортировать сначала по возрастанию номера модуля, 
потом по убыванию относительного рейтинга и, наконец, по имени студента в алфавитном порядке.*/

SELECT module_id Модуль,
    student_name Студент,
    COUNT(DISTINCT step_id) AS Пройдено_шагов,
    ROUND(
    		COUNT(DISTINCT step_id)/
            MAX(COUNT(DISTINCT step_id)) OVER (PARTITION BY module_id) * 100,
         1) AS Относительный_рейтинг
FROM lesson
    INNER JOIN step USING(lesson_id)
    INNER JOIN step_student USING(step_id)
    INNER JOIN student USING(student_id)
WHERE result = 'correct'
GROUP BY module_id, student_name
ORDER BY module_id, Относительный_рейтинг DESC, student_name;



10. /*Для студента с именем student_59 вывести следующую информацию по всем его попыткам:

1) информация о шаге: номер модуля, символ '.', позиция урока в модуле, символ '.', позиция шага в модуле;
2) порядковый номер попытки для каждого шага - определяется по возрастанию времени отправки попытки;
3) результат попытки;
4) время попытки (преобразованное к формату времени) - определяется как разность между временем отправки попытки и времени ее начала, 
в случае если попытка длилась более 1 часа, то время попытки заменить на среднее время всех попыток пользователя по всем шагам без учета 
тех, которые длились больше 1 часа;
5) относительное время попытки  - определяется как отношение времени попытки (с учетом замены времени попытки) к суммарному времени всех 
попыток  шага, округленное до двух знаков после запятой.
Столбцы назвать  Студент,  Шаг, Номер_попытки, Результат, Время_попытки и Относительное_время. Информацию отсортировать сначала по 
возрастанию id шага, а затем по возрастанию номера попытки (определяется по времени отправки попытки).

Важно. Все вычисления производить в секундах, округлять и переводить во временной формат только для вывода результата.*/

SET @avg_time = (
    SELECT AVG(submission_time - attempt_time)
    FROM step_student
    WHERE student_id = '59' AND (submission_time - attempt_time) / 3600 < 1
);
    
WITH q1 AS (
SELECT student_name AS Студент,  
    CONCAT(module_id, '.', lesson_position, '.', step_position) AS Шаг, 
    ROW_NUMBER () OVER (PARTITION BY step_id ORDER BY submission_time) AS Номер_попытки, 
    result, 
    step_id,
    IF((submission_time - attempt_time) / 3600 > 1, ROUND(@avg_time, 0), submission_time - attempt_time) AS Секунды
FROM step_student
    INNER JOIN step USING(step_id)
    INNER JOIN student USING(student_id)
    INNER JOIN lesson USING(lesson_id)
WHERE student_name = 'student_59')

SELECT Студент, 
    Шаг, 
    Номер_попытки, 
    result AS Результат, 
    SEC_TO_TIME(Секунды) AS Время_попытки,
    ROUND(Секунды / SUM(Секунды) OVER (PARTITION BY step_id) * 100, 2) AS Относительное_время
FROM q1
ORDER BY step_id, Номер_попытки